# Chapter 08 - 웹 어플리케이션을 위한 범용 Javascript

> 자바스크립트는 웹 개발자들에게 직접 브라우저에서 코드를 실행하여 보다 동적이고 상호작용이 뛰어난 웹 사이트를 구축할 수 있도록 한다는 목표를 가지고 1995년에 탄생하였다. 초창기 자바스크립트는 매우 간단하고 제한된 언어였지만, 오늘날 모든 종류의 어플리케이션을 만들기 위해 브라우저 외부에서도 사용할 수 있는 완전한 범용 언어로 간주될 수 있다. 플랫폼과 장치 전반에 걸친 가용성은 동일한 프로젝트의 여러 환경에서 코드의 재사용성을 단순화할 수 있는 새로운 경향을 자바스크립트 개발자들 사이에 촉진시키고 있다. Node.js와 관련하여 가장 의미있는 사례는 서버와 브라우저 사이에 코드를 공유하기 쉬운 웹 어플리케이션을 만들 수 있는 기회에 관한 것이다. 코드 재사용을 위한 이 질문은 원래 동형 자바스크립트(Isomorphic Javascript)로 구분되었지만 이제는 범용 자바스크립트(Universal Javascript)로 널리 인식되고 있다.

## 1. 브라우저와 코드 공유하기

### 1-1 모듈 공유

<p>
    서버에서 사용하는 모듈 시스템과 브라우저에서 사용되는 모듈 시스템은 일치하지 않는다. 브라우저에서는 `require()` 함수 혹은 모듈을 해석할 수 있는 파일 시스템이 없다. 따라서 두 플랫폼에서 작동할 수 있는 시스템을 사용하려면 추가적인 단계를 수헹해야 된다.
</p>

#### 범용 모듈 정의

- 모듈 시스템이 전혀 없는 환경이 있을 수도 있다. 즉, 전역이 다른 모듈들을 액세스하기 위한 주된 메커니즘이다.
- RequireJS와 같이 비동기 모듈 정의 로더 기반의 환경을 가질 수 있다.
- CommonJS 모듈 시스템을 추상화한 환경을 가지고 있을 수도 있다.

#### UMD(Universal Module Definition) 모듈 만들기

<p>
    아래의 코드는 UMD의 다양한 변형들 중 하나로 AMD, CommonJS 및 브라우저 전역과 같은 일반적인 모듈 시스템들을 지원할 수 있다. 간단한 템플릿 엔진인 mustache에 대한 외부 종속성을 가진 모듈을 정의하며, 최종적으로 제공하는 것은 `sayHello()`라는 메소드를 가진 객체로 mustache 템플릿을 렌더링하여 호출자에게 반환한다. UMD의 목표는 다른 환경에서 사용 가능하도록 다른 모듈 시스템과 통합하는 것이다.
</p>

```javascript
(function(root, factory) { // 1.
    if(typeof define === 'function' && define.amd) { // 2.
        define(['mustache'], factory);
    } else if(typeof module === 'object' && // 3.
        typeof module.exports === 'object') {
        var mustache = require('mustache');
        module.exports = factory(mustache);
    } else { // 4.
        root.UmdModule = factory(root.Mustache);
    }
}(this, function(mustache) { // 5.
    var template = '<h1>Hello <i>{{name}}</i></h1>';
    mustache.parse(template);

    return {
        sayHello:function(toWhom) {
            return mustache.render(template, {name: toWhom});
        }
    };
}));
```

1. 노출식 모듈(Revealing Module) 패턴과 매우 유사한 익명의 자체 실행(anoymous self-executing) 함수로 둘러 싸여진다. 이 함수는 시스템에서 사용할 수 있는 전역 네임스페이스 객체인 root를 받는다. 이는 주로 종속성을 글로벌 변수로 등록하는데 필요하다. 두 번째 인수는 모듈의 `factory()`인데, 모듈의 인스턴스를 반환하고 종속성을 입력으로 받아들이는 함수이다.
2. 먼저 AMD가 시스템에서 사용 가능한지 확인한다. define 함수와 AMD 플래그의 존재를 검증함으로써 이를 수행한다. 발견되면 시스템에 AMD 로더가 있음을 의미하므로 define을 사용하여 모듈을 등록하고 `factory()`에 종속성 mustache를 주입해야 한다.
3. `module`과 `module.exports` 객체의 존재를 검사하여 Node.js와 호환성이 있는 CommonJS 환경인지 여부를 확인한다. 이 경우 `require()`를 사용하여 모듈의 종속성을 로드하고 `factort()`에 제공한다. factort의 반환값은 `module.exports`에 할당된다.
4. 마지막으로 AMD나 CommonJS가 없다면 root 객체를 사용하여 전역 변수에 모듈을 할당한다. 브라우저 환경에서 root 객체는 일반적으로 window 객체이다. 또한 글로벌에 존재할 것으로 예상되는 종속성인 mustache를 어떻게 획득하는지도 볼 수 있다.
5. 마지막 단계에서 래퍼 함수 this 객체를 root에 제공하고 두 번째 인자로 모듈 팩토리를 제공하여 자가 호출(self-invoke)된다. 팩토리가 필요한 종속성을 인수로 받아들이는 방식을 볼 수 있을 것이다.

#### UMD 패턴에 대한 고려 사항

<p>
    UMD 패턴은 가장 많이 사용되는 모듈 시스템과 호환성을 갖춘 모듈을 만들 때 사용되는 효과적이고 간단한 기술이다. 하지만 각 환경에서 테스트하기 어렵고 오류가 발생하기 쉬운 많은 상용구들을 필요로 한다. 즉, UMD 상용구를 수동으로 작성한다는 것은 이미 개발 및 테스트된 단일 모듈을 랩핑하는 것이라는 것을 의미한다. 처음부터 새로운 모듈을 작성할 때는 사용하지 않는 것이 좋다. 따라서 이 경우 프로세스를 자동화하는데 도움이 되는 도구에 작업을 맡기는 것이 좋다. 이러한 도구 중 하나는 Webpack이다.
</p>

### 1-2 ES2015 모듈

<p>
    ES2015 사양에서 소개된 기능 중 하나는 내장(build-in) 모듈 시스템이며, CommonJS 및 AMD 모듈을 최대한 활용하는 것을 목표로 한다. 이 규격은 CommonJS와 마찬가지로 압축된 구문과 단일 exports를 선호하며 종속성 순환 지원을 제공한다. AMD와 마찬가지로 비동기 로드 및 환경 설정 가능한 모듈 로드를 직접 지원한다. 또한 선언적 구문(declarative syntax) 덕분에 정적 분석기(static analyzers)를 사용하여 정적 검사 및 최적화 같은 작업을 수행할 수 있다.
</p>

## 2. Webpack 소개

<p>
    웹팩은 Node.js 모듈 규칙을 사용하여 모듈을 작성한 다음, 컴파일 단계에서 모듈이 브라우저에서 작업하는데 필요한 모든 종속성을 포함하는 변들을 작성한다. 그런 다음 번들을 웹 페이지에 쉽게 불러오고 브라우저 내에서 실행할 수 있다. 웹 팩은 재귀적으로 소스를 스캔하고 `require()` 함수의 참조를 찾아서 해결한 다음 참조된 모듈을 번들에 포함시킨다.
</p>

### 2-1 Webpack 사용의 이점

- 브라우저와 호환되지 않는 모듈이 있는 경우, 이를 빌드에서 제외하거나 빈 객체나 다른 모듈로 대체하거나 브라우저와 호환 구현을 제공하는 다른 모듈로 바꿀 수 있다.
- 웹팩은 다른 모듈에 대한 번들을 생성할 수 있다.
- 웹팩은 서드파티 로더와 플러그인을 사용하여 소스 파일의 추가적인 처리를 가능하게 한다. 컴파일을 위한 CoffeeScript, TypeScript 또는 ES2015로부터 시작하여 AMD 로드를 지원하기 위해 `require()`를 사용하는 Bower와 Component 패키지에 이르기까지, 또 최소화에서 템플릿과 스타일시트와 같은 다른 리소스들의 컴파일과 번들링에 이르기까지 필요한 거의 모든 로더와 플러그인이 존재한다.
- Gulp 및 Grunt와 같은 작업 관리자에서 웹팩을 쉽게 호출할 수 있다.
- 웹팩을 사용하면 자바스크립트 파일뿐 아니라 스타일시트, 이밎, 폰트 및 템플릿과 같은 모든 프로젝트 리소스를 관리하고 전처리할 수 있다.
- 종속 트리를 분할하여 브라우저에서 필요할 때마다 로드할 수 있도록 웹팩을 구성할 수도 있다.
