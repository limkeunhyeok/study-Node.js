# Chapter 07 - 모듈 연결

## 1. 모듈과 의존성

<p>
    모든 어플리케이션은 여러 컴포넌트들을 결합한 결과이며, 어플리케이션이 커짐에 따라 이러한 컴포넌트를 연결하는 방식이 중요하다. 컴포넌트들이 너무 밀접하게 연결되어 있는 경우, 리팩토링이나 어플리케이션 전체 부분을 완전히 다시 작성하지 않고는 기능을 추가하거나 변경할 수 없게 된다.
</p>

### 1-1 Node.js의 가장 일반적인 종속성

<p>
    소프트웨어 아키텍처에서는 컴포넌트의 동작이나 구조에 영향을 미치는 엔티티, 상태 또는 데이터 형식을 종속성으로 간주할 수 있다. 종속성의 개념은 매우 광범위하며 때로는 평가하기가 어렵다. 하지만 Node.js에서는 일반적이며 쉽게 식별할 수 있는 필수 유형의 종속성을 바로 식별해낼 수 있다. 모듈은 코드를 구성하고 구조화하는데 필요한 기본적인 메커니즘이다. 실제 모듈의 속성은 다음과 같이 요약할 수 있다.
</p>

- 모듈은 (이성적으로는)보다 집중적이기 때문에 더 가독성이 높고 이해하기 쉽다.
- 별도의 파일로 표현되기 때문에 쉽게 식별할 수 있다.
- 모듈은 다른 어플리케이션보다 쉽게 재사용할 수 있다.

<p>
    모듈은 정보 은닉을 수행하는 완벽한 수준의 세분화된 단위를 나타내며 컴포넌트의 공개 인터페이스 만을 노출하는 효과적인 메커니즘을 제공한다.
</p>

<p>
    단순히 어플리케이션이나 라이브러리의 기능을 여러 모듈에 분산시키는 것만으로는 성공적인 디자인이라 할 수 없다. 잘못된 사용 중 한 가지는 모듈 간의 관계가 매우 강해서 독특한 모놀리식 개체를 만들어 내는 것이며, 그 상태에서 모듈을 제거하거나 교체하는 것이 아키텍처의 대부분을 뒤흔들게 되는 것이다.
</p>

### 1-2 응집력과 결합력

- 응집력(Cohesion)
  - 컴포넌트 기능 간의 상관 관계에 대한 측도
  - 단 한가지의 작업만 하는 모듈은, 모듈의 모든 부분이 그 하나의 단일 업무에서만 역활을 할 경우 높은 응집력을 가짐
  - 모든 유형의 객체를 데이터베이스에 저장하는 함수를 가진 모듈은 낮은 응집력을 가짐
- 결합력(Coupling)
  - 구성 요소가 시스템의 다른 구성 요소에 얼마나 의존하는지에 대한 측도
  - 모듈이 다른 모듈의 데이터를 직접 읽거나 수정한다면 다른 모듈과 밀접하게 연결
  - 전역이나 공유된 상태를 통해 상호작용하는 모듈들은 밀접한 결합(tightly coupled)
  - 매개 변수 전달을 통해서만 두 모듈이 통신한다면 느슨한 결합(loosely coupled)

<p>
    바람직한 시나이로는 높은 응집도와 느슨한 결합을 갖는 것이고, 이는 일반적으로 이해하기 쉽고 재사용 가능하며 확장 가능한 모듈을 만든다.
</p>

### 1-3 상태 저장(Stateful) 모듈

<p>
    자바스크립트에서는 모든 것이 하나의 객체이다. 인터페이스나 클래스와 같은 추상적인 개념이 없다. 동적 타이핑은 이미 인터페이스를 구현에서 분리하는 자연스러운 메커니즘을 제공한다.
</p>

#### Node.js의 싱글톤 패턴

<p>
    Node.js에서 단순히 `module.exports`를 사용하여 인스턴스를 내보내는 것만으로 싱글톤 패턴과 비슷한 것을 얻을 수 있다.
</p>

```javascript
// db.js
module.exports = new Database('my-app-db');
```

<p>
    단순히 데이터베이스의 새로운 인스턴스를 내보내는 것만으로도 현재 패키지 내에서 이미 db 모듈의 인스턴스가 하나만 있다고 가정할 수 있다. Node.js는 `require()`의 첫 번째 호출 이후에 모듈을 캐시할 것이고, 이후의 호출에서 다시 실행하지 않고 캐시된 인스턴스를 반환하기 때문에 가능하다.
</p>

<p>
    하지만 모듈은 전체 경로를 검색 키로 사용하여 캐시되므로 현재 패키지 내에서만 싱글톤이 보장된다. 각 패키지가 자신의 node_modules 디렉토리 내에 일련의 자신만의 종속성들을 가질 수 있으며, 이는 동일한 패키지의 다중 인스턴스를 초래할 수 있다. 결국 동일한 모듈의 서로 다른 인스턴스가 될 수도 있으며, 그 결과 더 이상 싱글톤이 아닐 수도 있게 된다.
</p>

```json
// package.json
{
    "name": "mydb",
    "main": "db.js"
}

// 종속성 트리
app/
    node_modules
        packageA
            node_modules
                mydb
        packageB
            node_modules
                mydb
```

<p>
    위에서 pacakgeA와 packageB는 모두 mydb 패키지에 종속성을 가지고 있다. 다음으로 메인 어플리케이션인 app 패키지는 pacakgeA와 packageB에 종속성을 가진다. 이 후에 `require('mydb')`를 호출하면, 필요로 하는 패키지에 따라 다른 디렉토리로 해석되기 때문에 pacakgeA와 packageB는 실제로 싱글톤처럼 보이는 두 개의 서로 다른 인스턴스를 로드한다. 이 시점에서 전역 변수를 사용하여 저장하지 않는 한, 싱글톤 패턴은 Node.js에 존재하지 않는다.
</p>

<p>
    이러한 상황은 피해야 하며, 대부분의 경우 싱글톤 패턴이 필요하지 않다. 또한 인스턴스를 공유하기 위한 다른 패턴이 있다.
</p>
