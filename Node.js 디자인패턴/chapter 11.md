# Chapter 11 - 메시징과 통합 패턴

<p>
    확장성이 분할에 관한 것이라면, 시스템 통합은 다시 결합에 관한 것이다. 분산 어플리케이션을 통합하는데는 두 가지 주요 기술이 있다. 하나는 공유 저장 장치를 중앙 조정자로 사용하고 모든 정보를 보관하는 것이며, 다른 하나는 메시지를 사용하여 시스템 노드 전체에 데이터, 이벤트 및 명령을 전파하는 것이다. 이 마지막 옵션은 분산 시스템을 확장할 때 실제로 차이를 만드는 부분이며, 복잡하게 만드는 원인이 되기도 한다.
</p>

<p>
    메시지는 소프트웨어 시스템의 모든 계층에서 사용된다. 인터넷 상에서 의사 소통을 하기 위해 메시지를 교환하고, 파이프를 사용하여 서로 다른 프로세스로 정보를 전송하기 위해 메시지를 사용할 수 있으며, 어플리케이션 내에서 직접적인 함수 호출의 대안으로 메시지를 사용할 수 있으며, 또한 장치 드라이버는 하드웨어와 통신하기 위해 메시지를 사용한다. 하지만 분산형 아키텍처를 다루는 경우 메시징 시스템이라는 용어는 네트워크를 통한 정보 교환을 용이하게 하기 위한 솔루션, 패턴 및 일련의 아키텍처를 말하는데 사용된다.
</p>

## 1. 메시징 시스템의 기본 사항

<p>
    메시지 및 메시징 시스템에 대해 이야기할 때 고려해야 할 4가지 기본요소는 다음과 같다.
</p>

- 단방향 또는 요청/응답 교환할 수 있는 통신의 방향
- 내용을 결정하는 메시지의 목적
- 즉시 또는 나중에(비동기식으로) 전송 및 수신할 수 있는 메시지 타이밍
- 직접 또는 브로커를 통해 발생할 수 있는 메시지의 전달

### 1-1 단방향 및 요청/응답 턴

![1](https://user-images.githubusercontent.com/38815618/106851182-1d560a80-66f9-11eb-879e-1fdcbe6bc970.PNG)

<p>
    단방향 통신의 일반적인 예로는 WebSocket을 사용하여 연결된 브라우저에 메시지를 보내는 이메일, 웹 서버 또는 일련의 작업자들에게 작업을 배포하는 시스템이 있다.
</p>

![2](https://user-images.githubusercontent.com/38815618/106851184-1deea100-66f9-11eb-9735-1a53527983cd.PNG)

<p>
    요청/응답 패턴의 일반적인 예로는 웹 서비스 호출이 있다. 구현하기 쉬운 패턴처럼 보일 수 있지만, 통신이 비동기이거나 여러 개의 노드가 포함되어 있으면 복잡해진다.
</p>

![3](https://user-images.githubusercontent.com/38815618/106851174-1b8c4700-66f9-11eb-987b-6a474c539b63.PNG)

<p>
    구성된 모든 노드 사이의 통신 방향을 관찰해보면 단방향이라고 볼 수 있지만, 전체 관점에서 볼 때 시작점에서 요청을 보내고 다른 노드로부터 응답을 받는다.
</p>

### 1-2 메시지 유형

<p>
    일반적으로 메시지의 목적에 따라 다음 세 가지 유형의 메시지를 식별할 수 있다.
</p>

- 명령 메시지
- 이벤트 메시지
- 도큐먼트 메시지

#### 명령 메시지(Command Message)

<p>
    이 메시지 유형의 목적은 수신 측에서 어떤 동작이나 작업을 수행하도록 하는 것이다. 이를 가능하게 하기 위해선 메시지에는 작업을 실행하는데 필요한 연산 명청, 실행에 주어지는 인자 값들과 같은 기본적인 정보를 가지고 있어야 한다. 명령 메시지는 원격 프로시저 호출(RPC) 시스템, 분산된 연산 수행, 간단하게는 데이터를 요청하는데 사용할 수 있다.
</p>

#### 이벤트 메시지(Event Message)

<p>
    이벤트 메시지는 다른 컴포넌트에 무엇인가가 발생했음을 알리는데 사용된다. 일반적으로 이벤트의 유형을 포함하며 컨텍스트, 주제 또는 관련된 수행자와 같은 세부적인 정보도 포함된다. 브라우저에서 롱 폴링(long polling)이나 WebSocket을 통하여 데이터가 변경되거나 일반적인 시스템의 상태가 변화되었을 때 서버로부터 알림을 받기 위해 이벤트 메시지를 사용한다. 이벤트의 사용은 시스템의 모든 노드를 동일한 페이지에서 유지할 수 있도록 하기 때문에 분산 어플리케이션에서 매우 중요한 통합 메커니즘이다.
</p>

#### 도큐먼트 메시지(Document Message)

<p>
    도큐먼트 메시지는 기본적으로 컴포넌트와 시스템 간의 데이터 전송을 의미한다. 도큐먼트가 명령과 구별되는 주요 특징은 수신자에게 데이터를 어떻게 처리할지 알려주는 정보가 메시지에 포함되어 있지 않다는 것이다. 다른 한편으로 이벤트 메시지와 주요한 차이는 주로 발생한 특정한 사건과 연관서잉 없다는 것이다. 일반적으로 명령 메시지에 대한 응답에는 요청된 데이터 또는 작업의 결과만 포함되므로 도큐먼트 메시지인 경우가 많다.
</p>

### 1-3 비동기 메시징 및 큐

<p>
    비동기 통신은 SMS와 비슷하다. 전송할 대 받는 사람을 네트워크에 연결할 필요가 없으며, 즉시 또는 일정 지연 후 응답을 받거나 전혀 응답을 받지 못할 경우도 있다. 여러 수신자에게 여러 개의 SMS를 차례로 보내고 응답하는 순서와 상관없이 응답을 받을 수 있다. 즉, 더 적은 리소스를 사용하고 더 나은 병렬 처리를 수행할 수 있다.
</p>

<p>
    비동기 통신의 또 다른 중요한 이점은 메시지를 저장한 후, 가능한 빨리 또는 일정 지연 후에 전달할 수 있다는 것이다. 이는 수신자가 새로운 메시지를 처리하기에 너무 바쁘거나 메시지 전달을 보장하고자 할 때 유용할 수 있다. 메시징 시스템에서는 다음 그림과 같이 보낸 사람과 받는 사람 간의 통신을 중재하고 메시지가 대상에 전달되기 전에 메시지를 저장하는 컴포넌트인 메시지 큐를 사용하여 이러한 작업을 수행할 수 있다.
</p>

![4](https://user-images.githubusercontent.com/38815618/106851176-1cbd7400-66f9-11eb-8dd6-3ab6f3604abc.PNG)

<p>
    어떠한 이유에서든 수신자가 충돌하거나 네트워크 연결이 끊어지거나 속도가 느려지는 경우, 메시지는 대기열에 쌓이고 수신자가 온라인 상태가 되어 정상화되는 즉시 발송된다. 대기열은 발신자에 위치하거나, 발신자와 수신자 간에 분리되어 위치하거나, 통신의 미들웨어 역활을 하는 외부의 전용 시스템에 존재할 수도 있다.
</p>

### 1-4 피어 투 피어 또는 브로커 기반 메시징

<p>
    메시지는 수신자에게 직접 P2P 방식으로 또는 메시지 브로커라는 중앙 중계 시스템을 통해 수신자에게 직접 전달될 수 있다. 브로커의 주된 역활은 메시지 수신자를 발신자로부터 분리하는 것이다.
</p>

![5](https://user-images.githubusercontent.com/38815618/106851179-1cbd7400-66f9-11eb-8a08-8dd2fa0813d5.PNG)

<p>
    피어-투-피어 아키텍처에서 모든 노드는 메시지를 수신자에게 직접적으로 전달한다. 이는 노드가 수신자의 주소와 포트를 알아야 하고 프로토콜과 메시지 형식을 이해하고 있어야 함을 의미한다. 브로커는 이러한 복잡성을 제거한다. 각 노드는 완전히 독립적일 수 있고, 세부 정보를 직접 알지 못하더라도 정의되지 않은 수 많은 피어들과 통신할 수 있다. 또한 브로커는 다른 통신 프로토콜 간의 브리지 역활을 할 수도 있다.
</p>

<p>
    디커플링 및 상호 운용성 외에도 브로커는 많은 브로커가 즉시 지원할 수 있는 광범위한 메시징 패턴을 굳이 언급하지 않고도 영구적인 큐(persistent queues), 라우팅(routing), 메시지 변환 및 모니터링과 같은 고급 기능을 제공할 수 있다. 물론, 피어-투-피어 아키텍처를 사용하여 이러한 모든 기능을 구현하는 것을 막을 수는 없지만, 불행히도 훨씬 더 많은 노력이 필요하다. 그럼에도 불구하고 브로커를 피해야 하는 몇 가지 이유가 있다.
</p>

- 단일 장애 지점의 제거
- 브로커는 확장해야 하는 반면, 피어-투-피어 아키텍처에서는 단일 노드만 확장하면 된다.
- 브로커 없이 메시지를 교환하면 전송 대기 시간을 크게 줄일 수 있다.
