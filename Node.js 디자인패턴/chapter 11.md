# Chapter 11 - 메시징과 통합 패턴

<p>
    확장성이 분할에 관한 것이라면, 시스템 통합은 다시 결합에 관한 것이다. 분산 어플리케이션을 통합하는데는 두 가지 주요 기술이 있다. 하나는 공유 저장 장치를 중앙 조정자로 사용하고 모든 정보를 보관하는 것이며, 다른 하나는 메시지를 사용하여 시스템 노드 전체에 데이터, 이벤트 및 명령을 전파하는 것이다. 이 마지막 옵션은 분산 시스템을 확장할 때 실제로 차이를 만드는 부분이며, 복잡하게 만드는 원인이 되기도 한다.
</p>

<p>
    메시지는 소프트웨어 시스템의 모든 계층에서 사용된다. 인터넷 상에서 의사 소통을 하기 위해 메시지를 교환하고, 파이프를 사용하여 서로 다른 프로세스로 정보를 전송하기 위해 메시지를 사용할 수 있으며, 어플리케이션 내에서 직접적인 함수 호출의 대안으로 메시지를 사용할 수 있으며, 또한 장치 드라이버는 하드웨어와 통신하기 위해 메시지를 사용한다. 하지만 분산형 아키텍처를 다루는 경우 메시징 시스템이라는 용어는 네트워크를 통한 정보 교환을 용이하게 하기 위한 솔루션, 패턴 및 일련의 아키텍처를 말하는데 사용된다.
</p>

## 1. 메시징 시스템의 기본 사항

<p>
    메시지 및 메시징 시스템에 대해 이야기할 때 고려해야 할 4가지 기본요소는 다음과 같다.
</p>

- 단방향 또는 요청/응답 교환할 수 있는 통신의 방향
- 내용을 결정하는 메시지의 목적
- 즉시 또는 나중에(비동기식으로) 전송 및 수신할 수 있는 메시지 타이밍
- 직접 또는 브로커를 통해 발생할 수 있는 메시지의 전달

### 1-1 단방향 및 요청/응답 턴

![1](https://user-images.githubusercontent.com/38815618/106851182-1d560a80-66f9-11eb-879e-1fdcbe6bc970.PNG)

<p>
    단방향 통신의 일반적인 예로는 WebSocket을 사용하여 연결된 브라우저에 메시지를 보내는 이메일, 웹 서버 또는 일련의 작업자들에게 작업을 배포하는 시스템이 있다.
</p>

![2](https://user-images.githubusercontent.com/38815618/106851184-1deea100-66f9-11eb-9735-1a53527983cd.PNG)

<p>
    요청/응답 패턴의 일반적인 예로는 웹 서비스 호출이 있다. 구현하기 쉬운 패턴처럼 보일 수 있지만, 통신이 비동기이거나 여러 개의 노드가 포함되어 있으면 복잡해진다.
</p>

![3](https://user-images.githubusercontent.com/38815618/106851174-1b8c4700-66f9-11eb-987b-6a474c539b63.PNG)

<p>
    구성된 모든 노드 사이의 통신 방향을 관찰해보면 단방향이라고 볼 수 있지만, 전체 관점에서 볼 때 시작점에서 요청을 보내고 다른 노드로부터 응답을 받는다.
</p>

### 1-2 메시지 유형

<p>
    일반적으로 메시지의 목적에 따라 다음 세 가지 유형의 메시지를 식별할 수 있다.
</p>

- 명령 메시지
- 이벤트 메시지
- 도큐먼트 메시지

#### 명령 메시지(Command Message)

<p>
    이 메시지 유형의 목적은 수신 측에서 어떤 동작이나 작업을 수행하도록 하는 것이다. 이를 가능하게 하기 위해선 메시지에는 작업을 실행하는데 필요한 연산 명청, 실행에 주어지는 인자 값들과 같은 기본적인 정보를 가지고 있어야 한다. 명령 메시지는 원격 프로시저 호출(RPC) 시스템, 분산된 연산 수행, 간단하게는 데이터를 요청하는데 사용할 수 있다.
</p>

#### 이벤트 메시지(Event Message)

<p>
    이벤트 메시지는 다른 컴포넌트에 무엇인가가 발생했음을 알리는데 사용된다. 일반적으로 이벤트의 유형을 포함하며 컨텍스트, 주제 또는 관련된 수행자와 같은 세부적인 정보도 포함된다. 브라우저에서 롱 폴링(long polling)이나 WebSocket을 통하여 데이터가 변경되거나 일반적인 시스템의 상태가 변화되었을 때 서버로부터 알림을 받기 위해 이벤트 메시지를 사용한다. 이벤트의 사용은 시스템의 모든 노드를 동일한 페이지에서 유지할 수 있도록 하기 때문에 분산 어플리케이션에서 매우 중요한 통합 메커니즘이다.
</p>

#### 도큐먼트 메시지(Document Message)

<p>
    도큐먼트 메시지는 기본적으로 컴포넌트와 시스템 간의 데이터 전송을 의미한다. 도큐먼트가 명령과 구별되는 주요 특징은 수신자에게 데이터를 어떻게 처리할지 알려주는 정보가 메시지에 포함되어 있지 않다는 것이다. 다른 한편으로 이벤트 메시지와 주요한 차이는 주로 발생한 특정한 사건과 연관서잉 없다는 것이다. 일반적으로 명령 메시지에 대한 응답에는 요청된 데이터 또는 작업의 결과만 포함되므로 도큐먼트 메시지인 경우가 많다.
</p>

### 1-3 비동기 메시징 및 큐

<p>
    비동기 통신은 SMS와 비슷하다. 전송할 대 받는 사람을 네트워크에 연결할 필요가 없으며, 즉시 또는 일정 지연 후 응답을 받거나 전혀 응답을 받지 못할 경우도 있다. 여러 수신자에게 여러 개의 SMS를 차례로 보내고 응답하는 순서와 상관없이 응답을 받을 수 있다. 즉, 더 적은 리소스를 사용하고 더 나은 병렬 처리를 수행할 수 있다.
</p>

<p>
    비동기 통신의 또 다른 중요한 이점은 메시지를 저장한 후, 가능한 빨리 또는 일정 지연 후에 전달할 수 있다는 것이다. 이는 수신자가 새로운 메시지를 처리하기에 너무 바쁘거나 메시지 전달을 보장하고자 할 때 유용할 수 있다. 메시징 시스템에서는 다음 그림과 같이 보낸 사람과 받는 사람 간의 통신을 중재하고 메시지가 대상에 전달되기 전에 메시지를 저장하는 컴포넌트인 메시지 큐를 사용하여 이러한 작업을 수행할 수 있다.
</p>

![4](https://user-images.githubusercontent.com/38815618/106851176-1cbd7400-66f9-11eb-8dd6-3ab6f3604abc.PNG)

<p>
    어떠한 이유에서든 수신자가 충돌하거나 네트워크 연결이 끊어지거나 속도가 느려지는 경우, 메시지는 대기열에 쌓이고 수신자가 온라인 상태가 되어 정상화되는 즉시 발송된다. 대기열은 발신자에 위치하거나, 발신자와 수신자 간에 분리되어 위치하거나, 통신의 미들웨어 역활을 하는 외부의 전용 시스템에 존재할 수도 있다.
</p>

### 1-4 피어 투 피어 또는 브로커 기반 메시징

<p>
    메시지는 수신자에게 직접 P2P 방식으로 또는 메시지 브로커라는 중앙 중계 시스템을 통해 수신자에게 직접 전달될 수 있다. 브로커의 주된 역활은 메시지 수신자를 발신자로부터 분리하는 것이다.
</p>

![5](https://user-images.githubusercontent.com/38815618/106851179-1cbd7400-66f9-11eb-8a08-8dd2fa0813d5.PNG)

<p>
    피어-투-피어 아키텍처에서 모든 노드는 메시지를 수신자에게 직접적으로 전달한다. 이는 노드가 수신자의 주소와 포트를 알아야 하고 프로토콜과 메시지 형식을 이해하고 있어야 함을 의미한다. 브로커는 이러한 복잡성을 제거한다. 각 노드는 완전히 독립적일 수 있고, 세부 정보를 직접 알지 못하더라도 정의되지 않은 수 많은 피어들과 통신할 수 있다. 또한 브로커는 다른 통신 프로토콜 간의 브리지 역활을 할 수도 있다.
</p>

<p>
    디커플링 및 상호 운용성 외에도 브로커는 많은 브로커가 즉시 지원할 수 있는 광범위한 메시징 패턴을 굳이 언급하지 않고도 영구적인 큐(persistent queues), 라우팅(routing), 메시지 변환 및 모니터링과 같은 고급 기능을 제공할 수 있다. 물론, 피어-투-피어 아키텍처를 사용하여 이러한 모든 기능을 구현하는 것을 막을 수는 없지만, 불행히도 훨씬 더 많은 노력이 필요하다. 그럼에도 불구하고 브로커를 피해야 하는 몇 가지 이유가 있다.
</p>

- 단일 장애 지점의 제거
- 브로커는 확장해야 하는 반면, 피어-투-피어 아키텍처에서는 단일 노드만 확장하면 된다.
- 브로커 없이 메시지를 교환하면 전송 대기 시간을 크게 줄일 수 있다.

## 2. 게시/구독 패턴

<p>
    이 패턴은 일련의 구독자가 특정 카테고리의 메시지를 수신하기 위해 구독을 등록한다. 반면 게시자는 모든 관련 구독자에게 배포되는 메시지를 생성한다.
</p>

![1](https://user-images.githubusercontent.com/38815618/107109097-a3508d80-6880-11eb-9099-d29217c596d2.PNG)

<p>
    pub/sub는 게시자가 메시지의 수신자가 누구인지 미리 알 필요가 없다. 특정 메시지를 받기 위해서는 구독자가 자신의 관심사를 등록해야 하므로 게시자는 알 수 없는 수의 수신자와 함께 작업할 수 있다. 즉, 게시/구독 패턴의 양쪽이 느슨하게 결합되어 있으므로 진화하는 분산 시스템의 노드를 통합하는데 이상적이다.
</p>

<p>
    브로커가 존재하면 구독자가 메시지의 게시자인 노드를 알지 못해 브로커와만 상호작용하기 때문에 시스템 노드 간의 분리가 더욱 개선된다. 또한, 브로커는 메시지 큐 시스템을 제공하여 노드 간의 연결 문제가 있는 경우에도 안정적인 전달을 보장한다.
</p>

### 2-1 간단한 실시간 채팅 어플리케이션 만들기

#### 서버 측 구현

```javascript
// app.js
const WebSocketServer = require('ws').Server;

// 정적 파일을 서비스하는 서버
const server = require('http').createServer( // 1.
    require('ecstatic')({root: `${__dirname}/www`})
);

const wss = new WebSocketServer({server: server}); // 2.
wss.on('connection', ws => {
    console.log('Client connected');
    ws.on('message', msg => { // 3.
        console.log(`Message: ${msg}`);
        broadcast(msg);
    });
});

function broadcast(msg) { // 4.
    wss.clients.forEach(client => {
        client.send(msg);
    });
}

server.listen(process.argv[2] || 8080);
```

1. 먼저 HTTP 서버를 만들고 정적 파일을 제공하기 위해 ecstatic이라는 미들웨어를 추가한다. 이는 어플리케이션의 클라이언트에서 필요로 하는 리소스들을 제공하는데 필요하다.
2. WebSocket 서버의 새 인스턴스를 만들고 이를 기존의 HTTP 서버에 연결한다. 그런 다음, 연결 이벤트에 대한 이벤트 리스너를 첨부하여 들어오는 WebSocket 연결에 대기한다.
3. 새로운 클라이언트가 서버에 연결될 때마다 수신 메시지로 전달되는 메시지를 듣기 시작한다. 새 메시지가 도착하면 연결된 모든 사용자에게 전파한다.
4. `broadcast()` 함수는 연결된 모든 클라이언트에 대해 `send()` 함수를 호출하는 단순한 반복을 수행한다.

#### 클라이언트 측 구현

```html
<!DOCTYPE html>
<html>
    <head>
        <script>
            var ws = new WebSocket('ws://' + window.document.location.host);
            ws.onmessage = function(message) {
                var msgDiv = document.createElement('div');
                msgDiv.innerHTML = message.data;
                document.getElementById('messages').appendChild(msgDiv);
            };
        
            function sendMessage() {
                var message = document.getElementById('msgBox').value;
                ws.send(message);
            }
        </script>
    </head>
    <body>
        Messages:
        <div id='messages'></div>
        <input type='text' placeholder='Send a message' id='msgBox'>
        <input type='button' onclick='sendMessage()' value='Send'>
    </body>
</html>
```

#### 채팅 어플리케이션 실행 및 확장

<p>
    한 인스턴스에서 채팅 메시지를 보낼 때, 메시지를 로컬로 브로드캐스트하여 특정 서버에 연결된 클라이언트들에게만 메시지를 전파한다. 실제로 두 서버는 서로 통신하지 않는다. 앞으로 이 두 서버를 통합해야 한다.
</p>

### 2-2 메시지 브로커로 Redis 사용하기

<p>
    Redis는 메시지 브로커라기 보다는 데이터베이스이다. 하지만 많은 기능 중에서 중앙 집중식 게시/구독 패턴을 구현하도록 특별하게 설계된 명령 쌍이 존재한다.
</p>

<p>
    Redis는 캐싱 서버나 세션 저장소와 같은 기존 인프라에서 사용할 수 있다. 속도와 유연성은 분산 시스템에서 데이터를 공유하기 위한 매우 보편적인 선택 기준이다. 따라서 프로젝트에서 구독/게시를 위한 브로커가 필요할 경우, 가장 간단하고 즉각적인 선택은 Redis 자체를 재사용하여 전용 메시지 브로커를 설치하고 유지 관리할 필요가 없도록 하는 것이다.
</p>

<p>
    앞으로 예제는 Redis를 메시지 브로커로 사용하여 채팅 서버를 통합한다. 각 인스턴스는 클라이언트에서 수신한 메시지를 브로커에 게시하는 동시에 다른 서버 인스턴스에서 오는 모든 메시지를 구독한다. 아키텍처의 각 서버는 구독자이면서 게시자이다.
</p>

![2](https://user-images.githubusercontent.com/38815618/107109098-a481ba80-6880-11eb-863d-22b144a1058c.PNG)

1. 메시지는 웹 페이지의 텍스트 상자에 입력되어 연결된 채팅 서버의 인스턴스로 전송된다.
2. 그런 다음 메시지가 브로커에 게시된다.
3. 브로커는 모든 가입자에게 메시지를 발송한다. 예제의 아키텍청에서는 채팅 서버의 모든 인스턴스가 대상이다.
4. 각 인스턴스에서 메시지는 연결된 모든 클라이언트에 전파된다.

```javascript
const WebSocketServer = require('ws').Server;
const redis = require("redis"); // 1.
const redisSub = redis.createClient();
const redisPub = redis.createClient();

// 정적 파일을 서비스하는 서버
const server = require('http').createServer(
    require('ecstatic')({root: `${__dirname}/www`})
);

const wss = new WebSocketServer({server: server});
wss.on('connection', ws => {
    console.log('Client connected');
    ws.on('message', msg => {
        console.log(`Message: ${msg}`);
        redisPub.publish('chat_messages', msg); // 2.
    });
});

redisSub.subscribe('chat_messages'); // 3.
redisSub.on('message', (channel, msg) => {
    wss.clients.forEach((client) => {
        client.send(msg);
    });
});

server.listen(process.argv[2] || 8080);
```

1. Node.js 어플리케이션을 Redis 서버에 연결하기 위해 사용 가능한 모든 Redis 명령을 지원하는 완전한 클라이언트인 Redis 패키지를 사용한다. 다음으로 두 개의 다른 연결을 인스턴스화 한다. 하나는 채널을 구독하고, 다른 하나는 메시지를 게시하는데 사용한다. Redis에서는 연결이 구독자 모드로 설정되면 구독과 관련된 명령만 사용할 수 있기 때문에 이 작업이 필요하다. 즉, 메시지 게시를 위해 두 번째 연결이 필요하다.
2. 연결된 클라이언트에서 새 메시지를 받으면 chat_messages 채널에 메시지를 게시한다. 서버가 동일한 채널에 가입되어 있어, Redis를 통해 다시 돌아올 것이기 때문에 메시지를 클라이언트에게 직접 브로드캐스트 하지 않는다.
3. 서버는 chat_messages 채널에도 가입해야 하므로, 현재 서버 또는 다른 대화 서버에서 해당 채널로 게시된 모든 메시지를 수신하도록 리스너를 등록한다. 메시지가 수신되면 현재 WebSocket 서버에 연결된 모든 클라이언트에 메시지를 브로드캐스트 한다.
