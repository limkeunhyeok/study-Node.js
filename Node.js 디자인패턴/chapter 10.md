# Chapter 10 - 확장성과 구조적 패턴

## 1. 어플리케이션 확장에 대한 소개

### 1-1 Node.js 어플리케이션 확장

<p>
    일반적인 Node.js 어플리케이션의 대부분의 작업이 싱글 스레드의 컨텍스트에서 실행된다. 논 블로킹 I/O에 의해 완벽하게 활용되는 싱글 스레드는 초당 수백 개의 짧은 요청을 처리하는 어플리케이션에 유용하다. 상용 하드웨어를 사용한다고 가정하면 싱글 스레드가 지원할 수 있는 용량은 서버의 성능에 관계없이 제한적이다. 따라서 부하가 많은 어플리케이션에 Node.js를 사용하려는 경우 유일한 방법은 멀티 프로세스와 멀티 머신에 확장하는 것이다.
</p>

<p>
    확장을 통해 작업량 뿐만 아니라 장애에 대한 가용성과 내성 같은 특성을 얻을 수 있다. 확장성은 어플리케이션의 크기와 복잡성에도 적용할 수 있는 중요한 개념이며, 확장 가능한 아키텍처를 구축하는 것은 소프트웨어 설계 시 또 다른 중요 요소이다.
</p>

### 1-2 확장성의 세 가지 차원

<p>
    확장성에서 필요한 첫 번째 기본 원칙은 멀티 프로세스와 멀티 시스템으로 어플리케이션의 부하를 분할하는 부하 분산(load distribution)이다. 이를 달성하는 방법으로 'The Art of Scalability'라는 저서에서는 스케일 큐브(Scale Cube)라고 하는 독창적인 모델을 제시한다. 이 모델은 다음 세 가지 측면에서 확장성을 설명한다.
</p>

- x축: 복제
- y축: 서비스/기능별 분해
- z축: 데이터 파티션 분할

![1](https://user-images.githubusercontent.com/38815618/106353007-b9af9400-632a-11eb-87ce-bc93a8c16eef.PNG)

<p>
    큐브의 왼쪽 아래 모서리는 모든 기능과 서비스를 단일 코드 베이스로한, 단일 인스턴스에서 실행되는 어플리케이션을 나타낸다. 이는 작은 작업량을 처리하거나 개발 초기 단계의 어플리케이션에 공통적인 상황이다.
</p>

<p>
    x축을 따라 확장하는 것은 간단하고 저렴하며 매우 효과적이다. 이 기술 이면의 원리는 동일한 어플리케이션을 n번 복제하고 각 인스턴스가 작업량의 1/n씩을 처리하도록 하는 것이다.
</p>

<p>
    y축을 따라 확장하면 해당 기능, 서비스 또는 유스케이스에 따라 어플리케이션이 분해된다. 이 경우 분해(decomposing)는 각기 다른 코드 베이스가 있는 다른 독립 실행형 어플리케이션을 생성하는 것을 의미하며, 때로는 전용 데이터베이스 또는 별도의 UI를 사용하여 생성하기도 한다. 어플리케이션을 기능별로 분리하는 기준은 주로 비즈니스 요구 사항, use case, 데이터 및 기타 여러 요소에 따라 다르다. 이는 어플리케이션의 아키텍처뿐만 아니라 개발 관점에서 관리되는 방식에도 큰 영향을 미치는 확장성(scale)에 대한 또 하나의 관점이다.
</p>

<p>
    z축을 따라 확장하는 것은 어플리케이션의 각 인스턴스를 전체 데이터의 일부의 처리만을 담당하도록 분할하는 것이다. 이는 주로 데이터베이스에서 사용되는 기술이며 수평 분할 또는 샤딩(sharding)이라 불린다. 이 설정에서는 동일한 어플리케이션의 인스턴스가 여러 개 있으며, 각 인스턴스는 서로 다른 기준을 사용하여 결정되는 데이터 파티션에서 작동한다. 데이터 파티션을 사용하려면 어플리케이션의 어느 인스턴스가 주어진 데이터를 담당하는지 결정하기 위해 각 작업 앞에 조회 단계가 있어야 한다. 데이터 파티셔닝(partitioning)은 대개 거대한 단일 데이터셋을 처리하는 것과 관련한 문제를 극복하기 때문에 데이터베이스 단에서 적용되고 처리된다. 어플리케이션 수준에서 이를 적용하는 것은 복잡하고 분산된 아키텍처 또는 매우 특별한 사용 사례에 대해서만 고려해 볼 가치가 있다. 복잡성을 감안할 때, z축을 따라 확장하는 것은 x, y축을 완전히 활용한 후에만 고려해야 한다.
</p>

## 2. 복제 및 로드 밸런싱

<p>
    전통적으로 멀티스레드 웹 서버는 일반적으로 시스템에 할당된 자원을 더 이상 업그레이드할 수 없거나, 단순히 다른 시스템을 도입하는 것보다 업그레이드에 더 많은 비용이 소요될 경우 확장된다. 멀티스레드를 사용함으로써 기존 웹 서버는 사용 가능한 모든 프로세서와 메모리를 사용하여 서버의 모든 처리 성능을 활용할 수 있다. 하지만 단일 Node.js 프로세스는 싱글스레드로 실행되고, 기본적으로 64비트 시스템에서는 1.7GB의 메모리 제한이 있다. 즉, Node.js 어플리케이션은 일반적으로 단일 시스템의 컨텍스트에서 조차 기존 웹 서버와 비교하여 모든 자원을 활용할 수 있도록 하기 위해 훨씬 빠르게 확장의 필요성이 대두된다.
</p>

<p>
    복제로 Node.js 어플리케이션을 확장하는 것은 비교적 간단해서 중복된 장애 방지 설정을 위해 더 많은 리소스를 확보할 필요가 없는 경우에도 구현되는 경우가 많다.
</p>

<p>
    이렇게 하면 개발자가 어플리케이션의 초기 단계에서 확장성을 고려하게 되어 어플리케이션이 여러 프로세스 또는 시스템에서 공유될 수 없는 리소스에 의존하지 않게 된다. 실제로 어플리케이션을 확장하기 위한 절대적인 전제 조건은 각 인스턴스가 공유할 수 없는 자원에 콩통 정보를 저장할 필요가 없어야 한다는 것이다.
</p>

### 2-1 클러스터 모듈

![1](https://user-images.githubusercontent.com/38815618/106360144-2b530680-635a-11eb-95b5-a5317a397fd4.PNG)

<p>
    Node.js에서 단일 시스템에서 실행되는 여러 개의 인스턴스 간에 어플리케이션의 부하를 분배하는 가장 간단한 패턴은 코어 라이브러리의 일부인 클러스터 모듈을 사용하는 것이다. 클러스터 모듈은 다음 그림과 같이 동일한 어플리케이션의 새 인스턴스를 간단하게 포킹(forking)하고 들어오는 연결을 자동으로 여러 인스턴스에 분산시킨다.
</p>

<p>
    마스터 프로세스는 확장하고자 하는 각 어플리케이션의 인스턴스를 나타내는 여러 프로세스를 생성한다. 들어오는 각 연결은 복제된 작업자들에게 나뉘어져 부하를 분산시킨다.
</p>

#### 클러스터 모듈의 동작에 대한 참고 사항

<p>
    Node.js 0.8 및 0.10 미만에서는 클러스터 모듈이 작업자 간에 동일한 서버 소켓을 공유하고 사용 가능한 작업자 간에 들어오는 연결의 로드 밸런싱 작업을 운영체제에 맡긴다. 이러한 방식은 사실, 운영체제가 작업자에게 부하를 분산시키기 위해 사용하는 알고리즘은 네트워크 요청을 로드 밸런싱하는 것이 아니라 프로세스의 실행을 예약하는 것이다. 결과적으로, 부하가 모든 인스턴스에 걸쳐 항상 균일하지 않다. 대개 일부 작업자가 대부분의 부하를 받는다. 이러한 유형의 동작은 서로 다른 프로세스 사이의 컨텍스트 전환을 최소화하는데 초점을 맞추기 때문에 운영체제 스케줄러에게는 적합할 수 있다. 간단히 말해 클러스터 모듈은 최대한의 잠재력을 발휘하지 못한다.
</p>

<p>
    이후의 버전에서는 명시적 라운드 로빈 로드 밸런스 알고리즘이 마스터 프로세스 내부에 포함되어 요청이 모든 작업자들에게 균등하게 배분된다. 새로운 로드 밸런스 알고리즘은 기본적으로 windows를 제외한 모든 플랫폼에서 사용 가능하다.
</p>

#### 간단한 HTTP 서버 만들기

```javascript
// app.js
const http = require('http');
const pid = process.pid;

http.createServer((req, res) => {
    for (let i = 1e7; i > 0; i--) {}
    console.log(`Handling request from ${pid}`);
    res.end(`Hello from ${pid}\n`);
}).listen(8080, () => {
    console.log(`Started ${pid}`);
});
```

<p>
    HTTP 서버는 PID가 포함된 메시지를 다시 전송하여 모든 요청에 응답한다. 이는 어떤 어플리케이션 인스턴스가 요청을 처리하는지 확인하는데 유용할 것이다. 또한 실제 CPU 작업을 시뮬레이션하기 위해 빈 루프를 천만번 수행한다. 이를 실행하고 네트워크 벤치마킹 도구를 사용하여, 서버가 하나의 프로세스만 사용하여 처리할 수 있는 초당 요청양을 측정할 수 있다.
</p>

#### 클러스터 모듈을 사용한 확장

```javascript
// clusteredApp.js
const cluster = require('cluster');
const os = require('os');

if(cluster.isMaster) {
    const cpus = os.cpus().length;
    for (let i = 0; i < cpus; i++) { // 1.
        cluster.fork();
    }
} else {
    require('./app'); // 2.
}
```

1. 커맨드 라인에서 clusteredApp을 실행하면 마스터 프로세스가 실행된다. cluster.isMaster 변수는 true로 설정되어 있으며 `cluster.fork()`를 사용하여 현재 프로세스를 포킹해야 한다. 앞의 예제에서 사용 가능한 처리 성능을 모두 활용하기 위해 시스템 CPU 수만큼 작업자를 실행한다.
2. 마스터 프로세스에서 `cluster.fork()`를 실행하면 현재 메인 모듈이 다시 실행되지만 이번에는 작업자 모드로 실행된다. 어플리케이션이 작업자로 실행되면 실제 작업을 시작할 수 있다. 이 예제에서는 실제로 새로운 HTTP 서버를 시작하는 app 모듈을 로드한다.

<p>
    이를 실행하면 각 요청에 대해 다른 PID를 가진 메시지를 반환한다. 즉, 요청이 다른 작업자에 의해 처리되어 부하가 분산되었다. 이렇게 하면 멀티 프로세스에서 어플리케이션을 확장하여 얻는 성능 향상을 발견할 수 있다. 만약 4개의 프로세서가 있는 리눅스 시스템에서 Node.js 6을 사용하면 평균 CPU 로드가 90%로 성능 향상이 약 3배가 된다.
</p>

#### 클러스터 모듈을 통한 복원성 및 가용성

<p>
    어플리케이션을 확장하는 것은 특히 오작동이나 갑작스러운 정지가 발생하는 상황에서도 일정한 수준의 서비스를 유지하는 능력과 같은 다른 이점을 가져올 수 있다. 이 속성을 복원성이라고 하며 시스템 가용성에 기여한다.
</p>

<p>
    동일한 어플리케이션의 여러 인스턴스를 시작함으로써 중복 시스템을 생성한다. 즉, 어떤 이유로든 하나의 인스턴스가 중단되더라도 요청을 처리할 수 있는 다른 인스턴스가 여전히 준비되어 있음을 의미한다.
</p>

<p>
    예제를 위해 app.js에 setTimeout과 Error 객체를 이용하여 일정 시간 후에 정지하도록 수정한다. 그 뒤 클러스터 모듈을 사용하여 작업자가 오류 코드로 종료되는 것을 감지하는 새로운 작업자를 생성한다.
</p>

```javascript
if (cluster.isMaster) {
    // ...

    cluster.on('exit', (worker, code) => {
        if (code != 0 && !worker.suicide) {
            console.log('Worker crashed. Starting a new worker');
            cluster.fork();
        }
    });
} else {
    require('./app');
}
```

<p>
    위의 코드는 마스터 프로세스가 exit 이벤트를 받자마자 프로세스가 의도적으로 종료되었는지, 에러로 종류되었는지 확인한다. 오류로 프로세스가 종료되었다면 새로운 작업자를 시작한다. 갑자기 종료된 작업자가 다시 시작되는 동안 다른 작업자가 요청을 계속 처리할 수 있으므로 어플리케이션의 가용성에는 영향을 미치지 않는다.
</p>

#### 다운타임이 없는(Zero-downtime) 재시작

<p>
    Node.js 어플리케이션 코드를 업데이트하면 다시 시작해야 할 수도 있다. 따라서  여러 인스턴스를 사용하면 어플리케이션의 가용성을 유지하는데 도움이 될 수 있다. 의도적으로 어플리케이션을 다시 시작하여 업데이트해야 할 경우, 다시 시작되고 요청을 처리할 수 없는 짧은 간격이 발생한다. 이에 해결책은 어플리케이션의 코드가 가용성에 영향을 미치지 않고 업데이트되도록 다운타임이 없는 재시작을 구현하는 것이다.
</p>

```javascript
// clusterApp.js

// ...

if (cluster.isMaster) {
  // ...
  
    process.on('SIGUSR2', () => { // 1.
        console.log('Restarting workers');
        const workers = Object.keys(cluster.workers);
        
        function restartWorker(i) { // 2.
            if (i >= workers.length) return;
            const worker = cluster.workers[workers[i]];
            console.log(`Stopping worker: ${worker.process.pid}`);
            worker.disconnect(); // 3.
            
            worker.on('exit', () => {
                if (!worker.suicide) return;
                const newWorker = cluster.fork(); // 4.
                newWorker.on('listening', () => {
                    restartWorker(i + 1); // 5.
                });
            });
        }
        restartWorker(0);
    });
} else {
    require('./app');
}
```

1. 작업자의 재시작은 SIGUSR2 시그널 수신 시 시작된다.
2. `restartWorker()`라는 반복 함수를 정의한다. 이는 cluster.workers 객체의 항목에 대해 비동기 순차 반복 패턴을 사용하여 구현한다.
3. `restartWorker()` 함수의 첫 번째 작업은 `worker.disconnect()`를 호출하여 작업자를 정상적으로 중지하는 것이다.
4. 종료된 프로세스가 제거되면 새로운 작업자를 생성할 수 있다.
5. 새로운 작업자가 준비되고 새로운 연결에 대한 listen이 준비되면, 반복의 다음 단계를 호출하여 다음 작업자를 재시작하는 작업을 계속적으로 진행한다.
